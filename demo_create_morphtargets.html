<!DOCTYPE html>
<html lang="en">
	
	<body>

		<div id="container"></div>
		

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "./node_modules/three/build/three.module.js",
					"three/addons/": "./node_modules/three/examples/jsm/"
				}
			}
		</script>
		<script src="https://dagrejs.github.io/project/graphlib/latest/graphlib.js"></script>

		<script type="module" src="./scripts/js/morph_target_creator.js"></script>
		
		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';

			import { ColladaLoader } from 'three/addons/loaders/ColladaLoader.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';


			import nose_vertices from './scripts/js/Nose_boss.json' assert { type: "json" };



			let container, stats, clock, controls, material;
			let camera, scene, renderer, mixer,active_mesh;
			let meshes = []; // mesh variables
			let clone,clone2, initial_size;

			//meshses dictionary 

			let mesh_dict = {
				"Test": {file: "./tfg/a/uploads_files_3895009_BOSS.dae"},
				"T2": {file: "./tfg/a/uploads_files_3895009_CLEOPATRA.dae"}
			}
			let mesh_names = Object.keys(mesh_dict);


			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, .1, 1000 );
				camera.position.set( 0, 2,  5 );

				scene = new THREE.Scene();

				clock = new THREE.Clock();

				// collada

				const loader = new ColladaLoader();

				var values = Object.values(mesh_dict);
				
				const loader2 = new GLTFLoader().setPath( './models/gltf/webmorph_models/test old assets/' );
				loader2.load( 'boss_v2.glb', function ( gltf ) {
					
					let gltf_mesh = gltf.scene.children[0].children[0];
                    console.log("boss", gltf_mesh);
                    //gltf_mesh = gltf.scene
                    gltf_mesh.name = "boss";
					gltf_mesh.position.x -=.5;
					//gltf_mesh.geometry.computeVertexNormals();
					scene.add(gltf_mesh);
					render();
					clone = gltf_mesh.clone();

				} );
				
				loader2.load( 'jen.glb', function ( gltf ) {

					let gltf_mesh = gltf.scene.children[0].children[0];
					console.log("jenn", gltf_mesh);
                    gltf_mesh.name = "jennifer";
					gltf_mesh.position.x +=.5;
					scene.add(gltf_mesh );
					render();
					clone2 = gltf_mesh.clone();
				});

					
				const gridHelper = new THREE.GridHelper( 10, 20, 0x888888, 0x444444 );
				scene.add( gridHelper );

				

				const ambientLight = new THREE.AmbientLight( 0xffffff, 0.2 );
				scene.add( ambientLight );

				const pointLight = new THREE.PointLight( 0xffffff, 0.8 );
				scene.add( camera );
				camera.add( pointLight );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.screenSpacePanning = true;
				controls.minDistance = 1;
				controls.maxDistance = 8000;
				controls.target.set( 0, 2, 0 );
				controls.update();

				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize );

				charactgersGUI(null);

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				const delta = clock.getDelta();

				if ( mixer !== undefined ) {

					mixer.update( delta );

				}

				renderer.render( scene, camera );

			}

			function areEqual( a1, a2){

				console.log(a1)
				console.log(a2)


				for (let index = 0; index < a1.length; index++) {
					if( a1[index] != a2[index]) return false	
				}

				return true; 
			}

			//gui 
			function charactgersGUI(meshes2) {

				const panel = new GUI( { width: 310 } );

				var controls = {
					Morph_meshes: 'Start',
					active_mesh: 0
				};

				var textures = {
					Selected_Texture: 'T1',
					avalible_textures: []
				};

				const params = {
					Morph: 0,
					Create_morph: Create_morph
				};
				
				function Create_morph(){
					console.log("Sceneeeeeee:", scene);
					const divisor = .001;

					let jen = clone2;
                    let boss = clone; 
					
                    //let nose2 = nose;
                    console.log("Clone two mesh nose******",jen , boss);
                    boss.geometry.computeVertexNormals();

					let temp = new THREE.Float32BufferAttribute( boss.geometry.attributes.position.array, 3 );
					let temp_normals = new THREE.Float32BufferAttribute( boss.geometry.attributes.normal.array, 3 );
					let temp2 = new THREE.Float32BufferAttribute( jen.geometry.attributes.position.array, 3 );
					let norm_morph = new THREE.Float32BufferAttribute( jen.geometry.attributes.normal.array, 3 );

					let material_1 = boss.material;
					let material_2 = jen.material;

					textures.avalible_textures = [material_1,material_2];
                                     
					let morphTargetMesh = new THREE.Mesh(boss.geometry.clone(), material_1);
					morphTargetMesh.geometry.computeVertexNormals();

					// Set buffer geometry as a morph target for the new mesh
					morphTargetMesh.name = "Blend";
					morphTargetMesh.morphTargetInfluences = [0, 0];
					morphTargetMesh.morphTargetDictionary = { 0: "default", 1: "morphTarget" };
					morphTargetMesh.geometry.morphAttributes.position = [];
					morphTargetMesh.geometry.morphAttributes.position = [];
					morphTargetMesh.geometry.morphAttributes.normal = [];

					morphTargetMesh.geometry.morphAttributes.position.push(  temp2 );
					morphTargetMesh.geometry.morphAttributes.normal.push(  norm_morph );

    				morphTargetMesh.geometry.morphTargetsRelative = false; //mode of blend not working
					morphTargetMesh.geometry.morphTargets = true;
					morphTargetMesh.geometry.morphNormals = true;

					scene.add(morphTargetMesh);
					render();
				}

				// panel.add(controls, 'Character', mesh_names).onChange( function ( value ) {
				// 	//unused					
				// });

				panel.add( params, 'Create_morph' ).name( 'Create morph character');

				panel.add(controls, 'Texture', [0,1]).onChange( function ( value ) {
					//change the textures between the two that we're blending 
					console.log(scene);
					scene.children[5].material  =  textures.avalible_textures[value];

				});

				panel.add( params, 'Morph', 0, 1 ).step( 0.01 ).onChange( function ( value ) {
					
                    scene.children[5].morphTargetInfluences[0]  =  value;
				});

				panel.onFinishChange(function (value) {
					// any change on gui parameters	
				});
				
			}

		</script>

	</body>
</html>
