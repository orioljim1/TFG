<!DOCTYPE html>
<html lang="en">
	
	<body>

		<div id="container"></div>
		

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		


		<script type="importmap">
			{
				"imports": {
					"three": "./node_modules/three/build/three.module.js",
					"three/addons/": "./node_modules/three/examples/jsm/"
				}
			}
		</script>
		<script src="https://dagrejs.github.io/project/graphlib/latest/graphlib.js"></script>

		

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';

			import { ColladaLoader } from 'three/addons/loaders/ColladaLoader.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';


			let container, stats, clock, controls, material;
			let camera, scene, renderer, mixer,active_mesh;
			let meshes = []; // mesh variables
			let clone,clone2, initial_size;

			//meshses dictionary 

			let mesh_dict = {
				"Test": {file: "./tfg/a/uploads_files_3895009_BOSS.dae"},
				"T2": {file: "./tfg/a/uploads_files_3895009_CLEOPATRA.dae"}
			}
			let mesh_names = Object.keys(mesh_dict);


			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, .1, 1000 );
				camera.position.set( 0, 2,  5 );

				scene = new THREE.Scene();

				clock = new THREE.Clock();

				const loader = new ColladaLoader();

				var values = Object.values(mesh_dict);
					
				const loader2 = new GLTFLoader().setPath( './models/gltf/webmorph_models/' );
				loader2.load( 'white.glb', function ( gltf ) {
					
					let gltf_mesh = gltf.scene.children[0];
					gltf_mesh.name = "head";
					gltf_mesh.position.x -=1;
					gltf_mesh.position.y +=1.7;
					gltf_mesh.scale.x *= .001;
					gltf_mesh.scale.y *= .001;
					gltf_mesh.scale.z *= .001;
					console.log("gltfas sccc", gltf.scene.children[0])
					scene.add(gltf_mesh );
					//render();

					clone = gltf_mesh.clone();

				} );
					
				const loader_face_jack = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );
				
				//loader2.setPath( './models/gltf/');
				//const loader2 = new GLTFLoader().setPath( './models/gltf/' );
				loader2.load( 'nose_white.glb', function ( gltf ) {

					let gltf_mesh = gltf.scene.children[0];
					gltf_mesh.name = "nose";
					console.log("mesh jack ", gltf_mesh);
					gltf_mesh.position.x +=.5;
					gltf_mesh.position.y +=1.7;
					gltf_mesh.scale.x *= .001;
					gltf_mesh.scale.y *= .001;
					gltf_mesh.scale.z *= .001;
					scene.add(gltf_mesh );

					//render();
					clone2 = gltf_mesh.clone();
				});

					
				const gridHelper = new THREE.GridHelper( 10, 20, 0x888888, 0x444444 );
				scene.add( gridHelper );

				

				const ambientLight = new THREE.AmbientLight( 0xffffff, 0.2 );
				scene.add( ambientLight );

				const pointLight = new THREE.PointLight( 0xffffff, 0.8 );
				scene.add( camera );
				camera.add( pointLight );


				const textureLoader = new THREE.TextureLoader();

					// Load a texture image file
					textureLoader.load('./tfg/a/Std_Skin_Body.png', (texture) => {
						// Create a new material with the texture
						material = new THREE.MeshBasicMaterial({map: texture});
					});

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.screenSpacePanning = true;
				controls.minDistance = 1;
				controls.maxDistance = 8000;
				controls.target.set( 0, 2, 0 );
				controls.update();

				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize );

				charactgersGUI(null);

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				const delta = clock.getDelta();

				if ( mixer !== undefined ) {

					mixer.update( delta );

				}

				renderer.render( scene, camera );

			}

			function areEqual( a1, a2){

				console.log(a1)
				console.log(a2)


				for (let index = 0; index < a1.length; index++) {
					if( a1[index] != a2[index]) return false	
				}

				return true; 
			}

			//gui 
			function charactgersGUI(meshes2) {

				const panel = new GUI( { width: 310 } );

				//panel.add(select, 'mesh', ['Mesh 1', 'Mesh 2']);
				var controls = {
					Morph_meshes: 'Start',
					active_mesh: 0
				};

				var textures = {
					Selected_Texture: 'T1',
					avalible_textures: []
				};

				const params = {
					Morph: 0,
				};
				
				//meshes[controls.active_mesh].visible = true;

				panel.add(controls, 'Character', mesh_names).onChange( function ( value ) {

				
					const divisor = .001;

					console.log("Clone two mesh child******",clone2);
					
					let pos2 = clone2.geometry.attributes.position.array.map(value => value * divisor);
					let temp = new THREE.Float32BufferAttribute( clone2.geometry.attributes.position.array, 3 );
					let temp_normals = new THREE.Float32BufferAttribute( clone2.geometry.attributes.normal.array, 3 );
					let temp2 = new THREE.Float32BufferAttribute( clone.geometry.attributes.position.array, 3 );
					let material_1 = clone.material;
					let material_2 = clone2.material;

					textures.avalible_textures = [material_1,material_2];

					clone2.position.x = 0;

					let morphTargetMesh = new THREE.Mesh(clone.geometry.clone(), material_1);

					clone2.geometry.attributes.position.array = clone2.geometry.attributes.position.array.map(value => value * divisor);

					// Set buffer geometry as a morph target for the new mesh
					morphTargetMesh.name = "Blend";
					morphTargetMesh.morphTargetInfluences = [0, 0];
					morphTargetMesh.morphTargetDictionary = { 0: "default", 1: "morphTarget" };
					morphTargetMesh.geometry.morphAttributes.position = [];
					morphTargetMesh.geometry.morphAttributes.position = [];
					morphTargetMesh.geometry.morphAttributes.normal = [];

					morphTargetMesh.geometry.morphAttributes.position.push(  temp );
					morphTargetMesh.geometry.morphAttributes.normal.push(  temp_normals );

					//morphTargetMesh.geometry.morphTargetsRelative = true; //mode of blend not working
					morphTargetMesh.geometry.morphTargets = true;
					morphTargetMesh.geometry.morphNormals = true;

					let eq = areEqual(clone2.geometry.attributes.position.array, clone2.geometry.attributes.position.array.map(value => value * divisor))
			
					morphTargetMesh.rotation.x += Math.PI / 2;
					morphTargetMesh.position.y +=1.7;
					morphTargetMesh.scale.x *= divisor;
					morphTargetMesh.scale.y *= divisor;
					morphTargetMesh.scale.z *= divisor;

					initial_size = morphTargetMesh.scale.x;

					morphTargetMesh.geometry.computeVertexNormals();
					scene.add(morphTargetMesh);
					render();
					
				});


				panel.add(controls, 'Texture', [0,1]).onChange( function ( value ) {
					//change the textures between the two that we're blending 
					//scene.children[5].material  =  textures.avalible_textures[value];

					console.log("Scene **", scene);

					console.log("Array 1", clone.geometry.attributes.position);
					console.log("Array 2", clone2.geometry.attributes.position);

					
					let min = 999999999;
					let max = 0;
					//const index = clone.geometry.attributes.position.array.indexOf(14.690468788146973);
					//const index = clone.geometry.attributes.position.array.indexOf(clone2.geometry.attributes.position.array[0]);
					for (let index = 0; index < clone2.geometry.attributes.position.array.length; index++) {
						
						const idx = clone.geometry.attributes.position.array.indexOf(clone2.geometry.attributes.position.array[index]);
						min = idx < min ? idx : min;
						max = idx > max ? idx : max;
					}

						let iidx = clone.geometry.attributes.position.array.indexOf(clone2.geometry.attributes.position.array[0]);
						let fidx = clone.geometry.attributes.position.array.indexOf(clone2.geometry.attributes.position.array[clone2.geometry.attributes.position.array.length-1]);
						
						console.log(iidx, fidx);
						console.log(min , max);



				});


				panel.add(controls, 'nose find', [0,1]).onChange( function ( value ) {
					

					console.log("Pre", clone.geometry.attributes.position.array );
					clone.geometry.attributes.position.array = sliceArray(clone.geometry.attributes.position.array,50136 , 73256);
					console.log("Post", clone.geometry.attributes.position.array );

					let noese_geom = new THREE.Mesh(clone.geometry.clone());

					noese_geom.geometry.computeVertexNormals();
					let divisor = .001
					noese_geom.scale.x *= divisor;
					noese_geom.scale.y *= divisor;
					noese_geom.scale.z *= divisor;
					noese_geom.position.x = 0;
					noese_geom.name = "clone";
					scene.add(noese_geom);
					render()

				});

				panel.add( params, 'Morph', 0, 1 ).step( 0.01 ).onChange( function ( value ) {
					//Set the morph amount for the blended mesh
					scene.children[5].morphTargetInfluences[0]  =  value;
				});

				panel.onFinishChange(function (value) {
					// any change on gui parameters	
				});
				
			}


			function sliceArray(mainArray, startIndex, endIndex) {
				return mainArray.slice(startIndex, endIndex + 1);
			}


		</script>

	</body>
</html>
