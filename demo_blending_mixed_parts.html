<!DOCTYPE html>
<html lang="en">
	<head>
		
		<link rel="stylesheet" href="main.css">
	  </head>
	
	<body>

		<div id="loading-screen" >
			<div class="spinner"></div>
			<h1>Loading...</h1>
		</div>
		  
		  
		<div id="container" class="hidden"></div>
		

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "./node_modules/three/build/three.module.js",
					"three/addons/": "./node_modules/three/examples/jsm/"
				}
			}
		</script>
		<script src="https://dagrejs.github.io/project/graphlib/latest/graphlib.js"></script>

		<script type="module" src="./scripts/js/morph_target_creator.js"></script>
		
		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';

			import { ColladaLoader } from 'three/addons/loaders/ColladaLoader.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			import nose_vertices from './scripts/js/nose_test_3.json' assert { type: "json" };

			let Models_dict= {
				"Boss": 'boss.glb',
				"Jen": "jen.glb",
				"Cleo": "cleo.glb",
				"Jack": "jack_bm.glb"
			}

			let container, stats, clock, controls, material;
			let camera, scene, renderer, mixer,active_mesh;
			let meshes = []; // mesh variables
			let clone,clone2, initial_size;
			let selection_state,base_selection, morph_selection; // variables to manage the selection processs;
			
			//App flow
			await init();
			setTimeout(swap_visibility, 2000);
			selection_state = "base";
			
			animate();

			async function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, .1, 1000 );
				camera.position.set( 0, 2,  5 );

				scene = new THREE.Scene();

				clock = new THREE.Clock();
		
				

				// loader2.load( 'boss.glb', function ( gltf ) {
					
				// 	let gltf_mesh = findHead(gltf.scene);
				// 	//let gltf_mesh = gltf.scene.children[0].children[0].children[0];
                //     gltf_mesh.name = "boss";
				// 	gltf_mesh.position.x -=.5;
				// 	gltf_mesh.geometry.computeVertexNormals();
				// 	scene.add(gltf_mesh);
				// 	render();
				// 	clone = gltf_mesh.clone();

				// } );
				
				// loader2.load( 'jen.glb', function ( gltf ) {

				// 	let gltf_mesh = findHead(gltf.scene);
				// 	//let gltf_mesh = gltf.scene.children[0].children[0].children[0];
                //     gltf_mesh.name = "jennifer";
				// 	gltf_mesh.position.x +=.5;
				// 	scene.add(gltf_mesh );
				// 	render();
				// 	clone2 = gltf_mesh.clone();
				// });

				// loader2.load( 'jack_bm.glb', function ( gltf ) {

				// 	let gltf_mesh = findHead(gltf.scene);
				// 	//let gltf_mesh = gltf.scene.children[0]

				// 	gltf_mesh.position.x -=1;
				// 	scene.add(gltf_mesh);
				// 	render();
				// 	clone= gltf_mesh.clone();

				// } );

				// loader2.load( 'cleo.glb', function ( gltf ) {


				// 	// let gltf_mesh = gltf.scene.children[0];
				// 	// let son_idx = gltf_mesh.children.findIndex(obj => obj.name === "Head");
				// 	let gltf_mesh = findHead(gltf.scene);

				// 	//gltf_mesh = gltf_mesh.children[son_idx];
				// 	gltf_mesh.position.x +=1;
				// 	scene.add(gltf_mesh );
				// 	render();
				// 	//clone2 = gltf_mesh.clone();
				// });
				
				const gridHelper = new THREE.GridHelper( 10, 20, 0xffffff, 0x444444 );
				scene.add( gridHelper );

				const ambientLight = new THREE.AmbientLight( 0xffffff, 0.2 );
				scene.add( ambientLight );

				const pointLight = new THREE.PointLight( 0xffffff, 0.8 );
				scene.add( camera );
				camera.add( pointLight );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				renderer.setClearColor(0xbfe3dd);

				controls = new OrbitControls( camera, renderer.domElement );
				controls.screenSpacePanning = true;
				controls.minDistance = 1;
				controls.maxDistance = 8000;
				controls.target.set( 0, 2, 0 );
				controls.update();

				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize );

				await importAssets(Models_dict);
				render();
				//charactgersGUI(null);
			
			}

			function swap_visibility(){
				var c = document.getElementById('container');
				c.classList.toggle('hidden');
				c = document.getElementById('loading-screen');
				c.classList.toggle('hidden')
				charactgersGUI(null);
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				const delta = clock.getDelta();

				if ( mixer !== undefined ) {

					mixer.update( delta );

				}

				renderer.render( scene, camera );

			}

			function areEqual( a1, a2){

				console.log(a1)
				console.log(a2)


				for (let index = 0; index < a1.length; index++) {
					if( a1[index] != a2[index]) return false	
				}

				return true; 
			}

			//gui 
			function charactgersGUI(meshes2) {

				const panel = new GUI( { width: 310 } );

				var controls = {
					Morph_meshes: 'Start',
					active_mesh: 0
				};

				var textures = {
					Selected_Texture: 'T1',
					avalible_textures: []
				};

				const params = {
					Morph: 0,
					Create_morph: Create_morph
				};
				
				function Create_morph(){
                    //function that creates the model that will be morphed;
					let jen = clone2;
                    let boss = clone; 
					
                    //let nose2 = nose;
                    boss.geometry.computeVertexNormals();

					console.log("j", jen);

					console.log("c2", boss);

					let source_p = new THREE.Float32BufferAttribute( boss.geometry.attributes.position.array, 3 );
					let source_n = new THREE.Float32BufferAttribute( boss.geometry.attributes.normal.array, 3 );
					let target_p = new THREE.Float32BufferAttribute( jen.geometry.attributes.position.array, 3 );
					let target_n = new THREE.Float32BufferAttribute( jen.geometry.attributes.normal.array, 3 );

					let material_1 = boss.material;
					let material_2 = jen.material;

					textures.avalible_textures = [material_1,material_2];
                                     
					let morphTargetMesh = new THREE.Mesh(boss.geometry.clone(), material_1);
					morphTargetMesh.geometry.computeVertexNormals();

					// morphTargetMesh.position.x -=2;
					// morphTargetMesh.scale.x = 0.01;
					// morphTargetMesh.scale.y= 0.01;
					// morphTargetMesh.scale.z= 0.01;
					// morphTargetMesh.position.y -=.1;

					// Set buffer geometry as a morph target for the new mesh
					morphTargetMesh.name = "Blend";
					morphTargetMesh.morphTargetInfluences = [0, 0];
					morphTargetMesh.morphTargetDictionary = { 0: "Morph", 1: "morphTarget" };
					morphTargetMesh.geometry.morphAttributes.position = [];
					morphTargetMesh.geometry.morphAttributes.position = [];
					morphTargetMesh.geometry.morphAttributes.normal = [];

                    let mixed_p = morph_array_2(source_p,target_p, nose_vertices);
                    let mixed_n = morph_array_2(source_n, target_n, nose_vertices);

                    console.log("mixess", source_p, target_p);

                    let mt_p = new THREE.Float32BufferAttribute( mixed_p, 3 );
					let mt_n = new THREE.Float32BufferAttribute(mixed_n, 3 );

					morphTargetMesh.geometry.morphAttributes.position.push(  mt_p );
					morphTargetMesh.geometry.morphAttributes.normal.push(  mt_n );                  

    				morphTargetMesh.geometry.morphTargetsRelative = false; //mode of blend not working
					morphTargetMesh.geometry.morphTargets = true;
					morphTargetMesh.geometry.morphNormals = true;

					

					scene.add(morphTargetMesh);
					render();
				}

				// panel.add(controls, 'Character', mesh_names).onChange( function ( value ) {
				// 	//unused					
				// });

				panel.add( params, 'Create_morph' ).name( 'Create morph character');

				panel.add(controls, 'Texture', [0,1]).onChange( function ( value ) {
					//change the textures between the two that we're blending 
					console.log(scene);
					scene.children[6].material  =  textures.avalible_textures[value];

				});

				panel.add( params, 'Morph', 0, 1 ).step( 0.01 ).onChange( function ( value ) {
					
					let morph_idx = scene.children.findIndex(obj => obj.name === "Blend");
                    scene.children[morph_idx].morphTargetInfluences[0]  =  value;
				});

				panel.onFinishChange(function (value) {
					// any change on gui parameters	
				});
				
			}

            function morph_array(source, target, indices){
                //function to modify a position array 
                source = source.array;
                target = target.array
                indices= indices.vertices;

				let d = calculate_distances(source,target,indices);
				
                for (let i = 0; i < source.length; i+=3) {

					const index = i / 3;

                    if(indices.includes(index)){
						// Swap the values of the current vertex with the corresponding vertex in target
										
						source[i] = target[i] ;
						source[i + 1] = target[i + 1] + d.x// +.027;
						source[i + 2] = target[i + 2] +d.y -0.006 //+.01;
					
					} 
                }
				
                return source
            }


			function morph_array_2(source, target, indices){ //better optimized function that iterates the length of the object instead of the mesh which is x50 times smaller
                //function to modify a position array 
                source = source.array;
                target = target.array
                indices= indices.vertices;

				let d = calculate_distances(source,target,indices);
				
                for (let i = 0; i < indices.length; i++) {

					const index = indices[i] *3;
											
					source[index] = target[index] ;
					source[index + 1] = target[index + 1] + d.x// +.027;
					source[index + 2] = target[index + 2] +d.y -0.006 //+.01;
					
					
                }
				
                return source
            }



			function calculate_distances(source, target, indices){

				let dx=0 ;
				let dy = 0;
				let dz = 0;
				let i = 0;
				let a= []; 
				let b= [];


				for (let i = 0; i < source.length; i+=3) {

					const index = i / 3;

					if(indices.includes(index)){
						i++;
						// Swap the values of the current vertex with the corresponding vertex in target
						a.push(i);
						console.log("******************");
						dx += source [i] - target[i];
						dy += source[i+1] - target[i+1];
						dz += source[i+2] - target[i+2];
									
					} 
				}


				// for (let i = 0; i < indices.length; i++) {
				// 	a.push(indices[i]);

				// 	const index = indices[i] *3;
											
				// 	dx += source [index] - target[index];
				// 	dy += source[index+1] - target[index+1];
				// 	dz += source[index+2] - target[index+2];


				// }

				
				console.log("distances", dx/indices.length, dy/indices.length , dz/indices.length);
				console.log("arr", a );

				return {x:dx, y:dy, z:dz}
			}
		
			// Define a variable to hold the currently selected object
			let selectedObject = null;

			// Add event listener for click event on renderer's DOM element
			renderer.domElement.addEventListener( 'click', function ( event ) {
				
				if(selection_state != "finished"){
					// Calculate mouse position in normalized device coordinates
					const mouse = new THREE.Vector2(); 
					mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

					// Create a raycaster from the camera to the clicked position
					const raycaster = new THREE.Raycaster();
					raycaster.setFromCamera( mouse, camera );

					// Check for intersections with objects in the scene
					const intersects = raycaster.intersectObjects( scene.children, true );

					// If there are intersections, select the first one
					if ( intersects.length > 0 && intersects[0].object.type != 'GridHelper' ) {

						// Deselect the previously selected object (if any)
						if ( selectedObject) {
							
							// Restore the original material
							selectedObject.material = material;
							selectedObject = null;
						}

						// Select the new object
						selectedObject = intersects[0].object;
						// Store the original material to restore it later
						material = selectedObject.material;
						// Set a new material to indicate selection (e.g. red color)
						//selectedObject.material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );

						selection_scheduler(selectedObject);

					}
				}
			} );

			function findHead(scene){

				while( scene.name != "Head"  ){
					
					let son_idx = scene.children.findIndex(obj => obj.name === "Head");
					// if  () scene= scene.children[son_idx]
					// else scene= scene.children[0]
					scene = son_idx !=-1 ? scene.children[son_idx] : scene.children[0];					
				}
				return scene;

			}

			async function importAssets(routes){
				//import assets
				const values = Object.values(routes);
				const loader_glb = new GLTFLoader().setPath( './models/gltf/webmorph_models/test old assets/export tests/Final_meshes/' );

				for (let i = 0; i < values.length; i++) {
					
					let route = values[i];
					loader_glb.load( route, function ( gltf ) {
					
					let gltf_mesh = findHead(gltf.scene);
					//let gltf_mesh = gltf.scene.children[0].children[0].children[0];
                    gltf_mesh.position.x += .25*(i+1) * (-1)**i ;
					if(gltf_mesh.type == 'Mesh')gltf_mesh.geometry.computeVertexNormals();
					scene.add(gltf_mesh);
					//render();
					//clone = gltf_mesh.clone();
					} );
				}

			}

			function selection_scheduler(sel_obj){

				if(selection_state == "base"){
					console.log(sel_obj);
					
					clone = sel_obj.clone();
					selection_state = "blend"
					scene.remove(sel_obj);

				}else if ( selection_state == "blend"){

					clone2 = sel_obj.clone();
					scene.remove(sel_obj);
					selection_state = "hold";
				}

			}

		</script>

	</body>
</html>
