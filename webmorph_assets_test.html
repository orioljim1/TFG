<!DOCTYPE html>
<html lang="en">
	
	<body>

		<div id="container"></div>
		

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		


		<script type="importmap">
			{
				"imports": {
					"three": "./node_modules/three/build/three.module.js",
					"three/addons/": "./node_modules/three/examples/jsm/"
				}
			}
		</script>
		<script src="https://dagrejs.github.io/project/graphlib/latest/graphlib.js"></script>

		

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';

			import { ColladaLoader } from 'three/addons/loaders/ColladaLoader.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';


			let container, stats, clock, controls, material;
			let camera, scene, renderer, mixer,active_mesh;
			let meshes = []; // mesh variables
			let clone,clone2;

			//meshses dictionary 

			let mesh_dict = {
				"Boss": {file: "./tfg/a/uploads_files_3895009_BOSS.dae"},
				"Cleo": {file: "./tfg/a/uploads_files_3895009_CLEOPATRA.dae"},
				"Eden": {file: "./tfg/a/uploads_files_3895009_EDEN.dae"},
				"Jack": {file: "./tfg/a/uploads_files_3895009_JACK.dae"},
				"Jen": {file: "./tfg/a/uploads_files_3895009_JENNIFER.dae"},
				"Sakura": {file: "./tfg/a/uploads_files_3895009_SAKURA.dae"}
			}
			let mesh_names = Object.keys(mesh_dict);

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 15, 10, - 15 );

				scene = new THREE.Scene();

				clock = new THREE.Clock();

				// collada

				const loader = new ColladaLoader();

				var values = Object.values(mesh_dict);
				
				// const loader2 = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );
				// loader2.load( 'face cut cleo.glb', function ( gltf ) {
					
				// 	let gltf_mesh = gltf.scene.children[0];
				// 	gltf_mesh.position.x -=.5;
				// 	console.log("gltfas sccc", gltf.scene.children[0])
				// 	scene.add(gltf_mesh );
				// 	//render();

				// 	clone = gltf_mesh.clone();

				// } );
				
				const loader2 = new GLTFLoader().setPath( './models/gltf/webmorph_models/' );
				loader2.load( 'asian.glb', function ( gltf ) {
					
					let gltf_mesh = gltf.scene.children[0];
					gltf_mesh.position.x -=.5;
					gltf_mesh.position.y +=1.7;
					gltf_mesh.scale.x *= .001;
					gltf_mesh.scale.y *= .001;
					gltf_mesh.scale.z *= .001;
					console.log("gltfas sccc", gltf.scene.children[0])
					scene.add(gltf_mesh );
					//render();

					clone = gltf_mesh.clone();

				} );
					
				const loader_face_jack = new GLTFLoader().setPath( 'models/gltf/DamagedHelmet/glTF/' );
				
				//loader2.setPath( './models/gltf/');
				//const loader2 = new GLTFLoader().setPath( './models/gltf/' );
				loader2.load( 'white.glb', function ( gltf ) {

					let gltf_mesh = gltf.scene.children[0];
					console.log("mesh jack ", gltf_mesh);
					gltf_mesh.position.x +=.5;
					gltf_mesh.position.y +=1.7;
					gltf_mesh.scale.x *= .001;
					gltf_mesh.scale.y *= .001;
					gltf_mesh.scale.z *= .001;
					scene.add(gltf_mesh );

					//render();
					clone2 = gltf_mesh.clone();
				});

					
				const gridHelper = new THREE.GridHelper( 10, 20, 0x888888, 0x444444 );
				scene.add( gridHelper );

				

				const ambientLight = new THREE.AmbientLight( 0xffffff, 0.2 );
				scene.add( ambientLight );

				const pointLight = new THREE.PointLight( 0xffffff, 0.8 );
				scene.add( camera );
				camera.add( pointLight );


				const textureLoader = new THREE.TextureLoader();

					// Load a texture image file
					textureLoader.load('./tfg/a/Std_Skin_Body.png', (texture) => {
						// Create a new material with the texture
						material = new THREE.MeshBasicMaterial({map: texture});
					});

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				//

				controls = new OrbitControls( camera, renderer.domElement );
				controls.screenSpacePanning = true;
				controls.minDistance = 1;
				controls.maxDistance = 8000;
				controls.target.set( 0, 2, 0 );
				controls.update();

				//

				stats = new Stats();
				container.appendChild( stats.dom );

				//

				window.addEventListener( 'resize', onWindowResize );

				charactgersGUI(null);

				//meshes[0].visible = true;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				const delta = clock.getDelta();

				if ( mixer !== undefined ) {

					mixer.update( delta );

				}

				renderer.render( scene, camera );

			}

			function areEqual( a1, a2){

				console.log(a1)
				console.log(a2)


				for (let index = 0; index < a1.length; index++) {
					if( a1[index] != a2[index]) return false	
				}

				return true; 
			}

			//gui 
			function charactgersGUI(meshes2) {

				const panel = new GUI( { width: 310 } );

				//panel.add(select, 'mesh', ['Mesh 1', 'Mesh 2']);
				var controls = {
					Character: 'Boss',
					active_mesh: 0
				};

				const params = {
					Spherify: 0,
					Twist: 0,
				};
				
				//meshes[controls.active_mesh].visible = true;

				panel.add(controls, 'Character', mesh_names).onChange( function ( value ) {

					//clone.morphAttributes.position = [];

					
					// let morphAttributes = {};
					// morphAttributes.position = [];
					// morphAttributes.position[0] = clone2.geometry.attributes.position;

					const divisor = .001;
					
					let pos2 = clone2.geometry.attributes.position.array.map(value => value * divisor);
					let temp = new THREE.Float32BufferAttribute( clone2.geometry.attributes.position.array, 3 );
					let temp_normals = new THREE.Float32BufferAttribute( clone2.geometry.attributes.normal.array, 3 );
					let temp2 = new THREE.Float32BufferAttribute( clone.geometry.attributes.position.array, 3 );
					
					// let temp = new THREE.Float32BufferAttribute( clone2.geometry.attributes.position.array.map(value => value * divisor), 3 );
					// let temp_normals = new THREE.Float32BufferAttribute( clone2.geometry.attributes.normal.array, 3 );
					// let temp2 = new THREE.Float32BufferAttribute( clone.geometry.attributes.position.array.map(value => value * divisor), 3 );

					//clone1.geometry.morphAttributes.position[120]= temp;

					console.log("cloned geometry****", clone);
					//clone.morphAttributes.position[ 1 ] = clone2.geometry.attributes.position;

					clone2.position.x = 0;
					//scene.add(clone2);

					const material = new THREE.MeshPhongMaterial( {
						color: 0xff0000,
						flatShading: true
					} );



					let morphTargetMesh = new THREE.Mesh(clone.geometry.clone(), material);

					clone2.geometry.attributes.position.array = clone2.geometry.attributes.position.array.map(value => value * divisor);

					// Set buffer geometry as a morph target for the new mesh
					morphTargetMesh.name = "Blend";
					morphTargetMesh.morphTargetInfluences = [0, 0];
					morphTargetMesh.morphTargetDictionary = { 0: "default", 1: "morphTarget" };
					morphTargetMesh.geometry.morphAttributes.position = [];
					// morphTargetMesh.geometry.setAttribute(
					// 	"morphTarget",
					// 	new THREE.Float32BufferAttribute(clone.geometry.attributes.position.array, 3)
					// );
					// morphTargetMesh.geometry.morphTargets = [];
					// morphTargetMesh.geometry.morphTargets.push( { name: "morph", vertices: temp2 } );

					morphTargetMesh.geometry.morphAttributes.position = [];
					morphTargetMesh.geometry.morphAttributes.normal = [];

					morphTargetMesh.geometry.morphAttributes.position.push(  temp );
					morphTargetMesh.geometry.morphAttributes.normal.push(  temp_normals );

					morphTargetMesh.geometry.morphTargetsRelative = true;

					console.log("Morphtarget reult: **", morphTargetMesh);

					let eq = areEqual(clone2.geometry.attributes.position.array, clone2.geometry.attributes.position.array.map(value => value * divisor))
					console.log("EQUAL ?????", eq );

					// //render();
					// let new_bg = new THREE.BufferGeometry();
					// new_bg = clone2.geometry.clone();

					// //geometries
					// //new_bg.attributes.positon = temp;
					// let geom1 = temp;
					// let geaom2= temp2;

					// //new_bg.morphAttributes.position[120]= temp2;
					// console.log("New bg", new_bg);

					

					// let mesh = new THREE.Mesh( new_bg, material );
					// mesh.name = "blend mesh";
					//mesh.position.y -= 160;
					//mesh.geometry.morphAttributes.position = [];
					//mesh.geometry.morphAttributes.position = [temp];

					//mesh.geometry.morphTargets = [];
					//mesh.geometry.morphTargets.push( { name: "morph", vertices: temp2 } );
					// mesh.computeVertexNormals();
					// mesh.computeMorphNormals();
					//mesh.geometry.computeVertexNormals();
                	//mesh.geometry.computeMorphNormals();
		
					//o.loadGeometry(geometry1);
					//o.material.morphTargets = true;
					//o.material.morphNormals = true;

					//mesh.geometry.morphAttributes.position[121] = temp;
					// let scale_factor = clone.scale.x;
					// mesh.rotation.x += Math.PI / 2;
					// mesh.position.y +=1.7;
					// mesh.scale.x *= .001;
					// mesh.scale.y *= .001;
					// mesh.scale.z *= .001;
					
					morphTargetMesh.rotation.x += Math.PI / 2;
					morphTargetMesh.position.y +=1.7;
					morphTargetMesh.scale.x *= .001;
					morphTargetMesh.scale.y *= .001;
					morphTargetMesh.scale.z *= .001;

					morphTargetMesh.geometry.computeVertexNormals();
					// mesh.geometry.computeMorphNormals();
					//mesh.position = clone.position;
					//mesh.scale = clone.scale;
					scene.add(morphTargetMesh);
					render();

					console.log("SCENE IS :", scene);
					
				});

				panel.add( params, 'Spherify', 0, 1 ).step( 0.01 ).onChange( function ( value ) {

					console.log("influences ::", scene.children[5]);
					scene.children[5].morphTargetInfluences[0]  = value;
					// console.log(value);

				});

				panel.onFinishChange(function (value) {

					
				});
				
			}

		</script>

	</body>
</html>
