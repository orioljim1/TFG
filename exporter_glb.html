<!DOCTYPE html>
<html lang="en">
	
	<body>

		<div id="container"></div>
		

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "./node_modules/three/build/three.module.js",
					"three/addons/": "./node_modules/three/examples/jsm/"
				}
			}
		</script>
		<script src="https://dagrejs.github.io/project/graphlib/latest/graphlib.js"></script>

		<script type="module" src="./scripts/js/morph_target_creator.js"></script>
		
		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';

			import { ColladaLoader } from 'three/addons/loaders/ColladaLoader.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
            import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';


			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';


			import nose_vertices from './scripts/js/Nose_boss.json' assert { type: "json" };



			let container, stats, clock, controls, material;
			let camera, scene, renderer, mixer,active_mesh;
			let meshes = []; // mesh variables
			let clone,clone2, initial_size;

			//meshses dictionary 

			let mesh_dict = {
				"Test": {file: "./tfg/a/uploads_files_3895009_BOSS.dae"},
				"T2": {file: "./tfg/a/uploads_files_3895009_CLEOPATRA.dae"}
			}
			let mesh_names = Object.keys(mesh_dict);


			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, .1, 1000 );
				camera.position.set( 0, 2,  5 );

				scene = new THREE.Scene();

				clock = new THREE.Clock();

				// collada

				const loader = new ColladaLoader();

				var values = Object.values(mesh_dict);
				
				const loader2 = new GLTFLoader().setPath( './models/gltf/webmorph_models/test old assets/export tests/final_meshes/' );
				loader2.load( 'cleo.glb', function ( gltf ) {
					
					let gltf_mesh = gltf.scene;
                    console.log("boss", gltf_mesh);
                    gltf_mesh.name = "Cleo";
					scene.add(gltf_mesh);
					render();
					clone = gltf_mesh

				} );
								
				const gridHelper = new THREE.GridHelper( 10, 20, 0x888888, 0x444444 );
				scene.add( gridHelper );

				

				const ambientLight = new THREE.AmbientLight( 0xffffff, 0.2 );
				scene.add( ambientLight );

				const pointLight = new THREE.PointLight( 0xffffff, 0.8 );
				scene.add( camera );
				camera.add( pointLight );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.screenSpacePanning = true;
				controls.minDistance = 1;
				controls.maxDistance = 8000;
				controls.target.set( 0, 2, 0 );
				controls.update();

				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize );

				charactgersGUI(null);

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				const delta = clock.getDelta();

				if ( mixer !== undefined ) {

					mixer.update( delta );

				}

				renderer.render( scene, camera );

			}

			function areEqual( a1, a2){

				console.log(a1)
				console.log(a2)


				for (let index = 0; index < a1.length; index++) {
					if( a1[index] != a2[index]) return false	
				}

				return true; 
			}

			//gui 
			function charactgersGUI(meshes2) {

				const panel = new GUI( { width: 310 } );
				var controls = {
					Morph_meshes: 'Start',
					active_mesh: 0
				};

				var textures = {
					Selected_Texture: 'T1',
					avalible_textures: []
				};

				const params = {
					Morph: 0,
                    export_glb: test,
                    trs: false,
                    onlyVisible: true,
                    binary: false,
                    maxTextureSize: 4096
				};

                function test(){
                    console.log("heyy")
                    exportGLTF(clone);
                }
				
				panel.add( params, 'export_glb' ).name( 'Export GLB' );

				panel.onFinishChange(function (value) {
					// any change on gui parameters	
				});
				
			}

            function mapValueToRange(value) {
                // const output = (1 - value) * 0.25 + 0.75;
                // return output;
                const output = (1 - value) * 0.5 + 0.5;
                return output;
            }

            const link = document.createElement( 'a' );
			link.style.display = 'none';
			document.body.appendChild( link ); // Firefox workaround, see #6594

            function save( blob, filename ) {

                link.href = URL.createObjectURL( blob );
                link.download = filename;
                link.click();

                // URL.revokeObjectURL( url ); breaks Firefox...

            }   

            function saveString( text, filename ) {
                save( new Blob( [ text ], { type: 'text/plain' } ), filename );
            }   

        function exportGLTF( input ) {

				const gltfExporter = new GLTFExporter();

                const params2 = {
                    trs: false,
                    onlyVisible: true,
                    binary: false,
                    maxTextureSize: 4096
				};

				const options = {
					trs: params2.trs,
					onlyVisible: params2.onlyVisible,
					binary: params2.binary,
					maxTextureSize: params2.maxTextureSize
				};
				gltfExporter.parse(
					input,
					function ( result ) {

						if ( result instanceof ArrayBuffer ) {

							saveArrayBuffer( result, 'scene.glb' );

						} else {

							const output = JSON.stringify( result, null, 2 );
							console.log( output );
							saveString( output, 'scene.glb' );

						}

					},
					function ( error ) {

						console.log( 'An error happened during parsing', error );

					},
					options
				);

		}

		</script>

	</body>
</html>
